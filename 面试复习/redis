### redis中的对象应用场景
- redis是什么？是一款开源的缓存数据库

redis与其他key-value缓存产品有以下三个特点：
redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候，可以再次加载进行使用。redis不仅仅支持简单的key-value
类型的数据，同时还提供list，set，zset，hash等数据结构的存储。redis支持数据的备份，即master-slave模式的数据备份。

- redis的优势？

性能极高－redis能读的速度是110000次/s，写的速度是81000次/s，丰富的数据结构－redis也支持二进制案例的strings,lists,hashs,sets以及ordered sets数据类型操作。
原子-redis的所有操作都是原子的，意思要么执行成功，要么失败完全不执行。单个操作是原子性的，多个操作也支持事务，即原子性，通知MULTI和EXEC指令包起来
丰富的特性  redis还支持publish/subscribe，通知，key过期等特性

redis为什么快？
- 完全基于内存，绝大部分的请求都是纯粹的内存操作，非常迅速
- 数据结构简单，对数据操作也很简单，redis中的数据结构是专门进行设计的
- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者对哦线程导致的切换而消耗CPU，不用考虑
各种锁的问题，不存在加锁释放锁的操作，没有因为可能出现死锁而导致的性能消耗
- 使用IO多路复用模型，非阻塞IO
- 使用低层模型不同，他们之间的底层实现方式以及客户端之间通信的应用协议不一样，redis直接自己构建了vm机制，因为一般的系统调用函数
会浪费一定时间去移动和请求

### redis存储和其他的key-value存储有什么不同？

redis有着更为复杂的数据结构并且提供对他们的原子性操作(不支持回滚)，这是一个不同于其他数据库的进化路径。redis的数据类型
都是基于基本数据结构的同时对程序员透明，无需额外的抽象。

redis运行在内存中都是可以持久化到磁盘的，所以在不同的数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面
的另一个优点是相比在磁盘上相同的复杂数据结构，在内存中操作起来更简单，这样redis可以做很多内部复杂性很强的事情，同时，在磁盘格式方面他们是紧凑的
以追加的方式产生的，因为他们并不需要进行随机访问。

### redis的数据类型

redis支持五种数据类型：string，hash，list，set以及zsetsorted set 有序集合

### 使用redis有哪些好处去？
- 速度快，因为数据在内存中，类似于hashmap，hashmap的优势就是查找和操作的时间复杂度都是o1
- 支持丰富的数据类型，五种对象
- 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行

### redis相比于memcached有哪些优势？
- memcacheed所有值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类
- redis的速度比memcached快
- redis可以持久化其数据

### memcache与redis的区别在哪里？
- 存储方式memcache将数据全部保存在内存中，断电后会挂掉，数据不能超过内存大小。redis有部分存在硬盘上，这样能保证数据的持久化。
- 数据支持类型memcache对数据类型支持相对简单，redis又复杂的数据类型
- 使用底层模型不同，他们之间底层实现方式以及与客户端之间通信的应用协议不一样。redis直接将自己构建了vm机制，因为一般的系统调用函数，会浪费一定的时间去移动和请求

### redis是单进程和单线程？

redis是单线程，利用队列技术将并发访问变成串行访问，消除了传统数据库串行控制的开销

一个字符串类型的值存储的最大容量是512MB

### redis的持久化机制是什么？各自的优缺点？

redis提供两种持久化机制rdb和aof机制：
rdb：是指数据集快照的方式持久化模式，记录redis数据库的所有键值对，某个时间点将数据写入一个临时文件，持久化结束后，
用临时文件替换上次持久化的文件，达到数据恢复。

优点：
- 只有一个dump.rdb，方便持久化
- 容灾性好，一个文件可以保存在安全的磁盘
- 性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化，使用单独子进程来进行持久化主进程不会进行任何IO操作，保证了redis的高性能
- 相对于数据集合大时，比AOF的启动效率高

缺点：
- 数据安全性低，rdb是间隔一段时间进行持久化，如果持久化之间redis发生了故障，会发生数据的丢失，所以这种方式也有不严谨的时候
- aof持久化：指所有命令记录以redis命令请求协议的个数完全持久化，保存在aof文件中。

优点：
- 数据安全，aof持久化可以配置爱appendfsync属性，有always，每进行一次命令操作就记录到aof文件中一次
- 通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具解决数据一致性问题
- aof机制的rewrite模式，aof文件没被rewrite之前（文件过大对命令进行合并重写），可以删除其中的某些命令

### 缺点

- aof文件比rdb文件大，且回复速度慢
- 数据大的时候，比rdb启动效率低

### redis常见性能问题

- master不要写内存快照，如果master写内存快照，save命令调度rdbsave函数，会阻塞主线程，当快照比较大的时候。性能影响是非常大的，会间断性暂停服务
- 如果数据比较重要，某个slave开启aof备份数据，策略设置为每妙同步
- 为了主从复制的速度和链接稳定性，master和slave最好在同一个局域网下
- 尽量避免在压力大的主库中增加从库
- 主从复制不要用图状结构，用单向链表结构更为稳定，即：master<-slave<-slave<-slave...这样的结构方便解决单点故障，实现slave和master的替换，如果master挂了，可以启动slave和master

### redis过期键的删除策略

- 定时删除：在设置过期时间的同时，创建一个定时器，让定时器在键的过期时间来临的时候，立即执行对键的删除
- 惰性删除：放任键过期不管，但是每次在键空间中获取键时，都检查获取过期键，过期就删除
- 定期检查：每隔一段时间，对数据库进行一次检查，删除里面的过期键，至于删除多少，以及检查多少个数据库，由算法决定

### redis的回收策略（淘汰策略）

-　从已设置过期时间的数据集合中挑选最近最少使用的数据淘汰
-  从已设置过期时间的数据集合中挑选将要过期的数据淘汰
-  从已经设置过期时间的数据集中任意选择数据进行淘汰
-  数据集合中选最近最少使用的数据淘汰
-  从数据集合中选择任意数据进行淘汰
-  禁止驱逐数据
如果数据呈现幂律分布，一部分数据访问频率高，一部分低，则使用allkeys-lru
如果数据呈现平等分布，也就是所有的数据对象频率都相同，则使用allkeys-random

### 为什么redis需要将所有数据存在内存中？

为了达到最快的数据访问速率，通过异步的方式将数据写入到磁盘中，所以redis具有快速和数据持久化的特征，
如果不将数据存在内存中，磁盘IO速度为严重影响redis的性能，在内存越来越便宜的今天，redis越来月受欢迎，如果设置了使用的内存，则数据已有记录数达到内存限制后不能继续插入新值。

### redis同步机制
- slave第一次启动的时候，链接master，发送psync命令，格式为psync runid(runid为master运行时的id) offset　slave自己复制的偏移量
此时是slave第一次连接master，slave不知道master的runid，也不知道自己的偏移量，这时候会传一个问号和-1，告诉节点是第一次同步
- 等master接收到psync　? -1时就知道slave是要全量复制，会将自己的runid和offsert告知slave，回复命令+fullresync runid offset，同时master会执行bgsave来生成rdb文件，并使用自己的缓冲区记录此后的所有写命令
slave接收到master的回复后，或保存runid和offset，slave此时处于同步状态，如果此时收到请求，当参数配置slave-server-stale-data 　yes时，会响应当前请求，no则会返回错误
- master bgsave执行完成，向slave发送rdb文件，同时继续缓冲此期间的写命令，rdb文件发送完成后，向slave发送存储缓冲区的写命令。
- slave收到rdb文件，丢弃所有旧数据，开始载入rdb文件；并执行master发来的所有存储在缓冲区中的写命令
- 此后master执行一个写命令，就向slave发送相同的写命令

简而概括，接收到slave同步，主先执行bgsave生程rdb文件，并将后续修改操作记录到buffer中，完成后，将rdb文件全量同步到从，复制界定啊接受完成后讲rdb镜像加载到内存中，加载完成后，再通知主节点将期间修改的
操作记录同步到复制节点进行重放就完成了整个同步过程。

### pipeline有什么好处？为什么要用pipeline？
可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性

### 是否使用过redis集群，原理是什么？

- redis 哨兵着眼于高可用，在master宕机时，会自动将slave提升为master，继续提供服务
- redis cluster着眼于扩展性，在单个redis内存不足的时候，使用cluster进行分片处理

### redis集群方案什么情况下会导致整个集群不可用？
在A、B、C三个节点的集群，在没有复制模型的情况下，如果节点B失败了，那么整个集群就会以为缺少了5501-11000这个范围的槽导致不可用


