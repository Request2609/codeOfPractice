当调用一个函数的时候，程序从函数头部开始执行，当函数退出
时，这个函数的声明周期也就结束了。一个函数在它的生命周期中
只能返回一次。
而协程在执行过程中，可以调用别的协程自己则途中退出执行，之后
又从调用别的协程的地方恢复运行。比较像线程，线程执行过程中
有可能被挂起，让位于别的线程执行，稍后又从挂起的地方恢复执行。
在这个过程中，协程与协程之间实际上不是普通“调用者与被调用者”的
关系，他们之间的关系是对称的。

libco是一种非对称的协程，即跟一个特定调用者绑定的，协程让出CPU，只能让回给原来的调用者。
非对称在于程序控制流移到被调用协成时使用的是call/resume操作。当被调用协程让出CPU时使用的却是
return/yield操作。此外，协程间的地位也不对等，caller和callee关系是确定的，不可更改的，非对称协程只能
返回最初调用它的协程。

对称协程则不一样，启动之后就跟启动之前的协程没有关系，协成的切换操作，一般而言只是一个操作yield，用于将程序控制
流转移给另外协程。对称协程机制一般需要一个调度器的支持，按一定的调度算法选择yield的目标协程。

libco中提供的协程，虽然编程接口跟pthread有点类似，，本质上却是一种非对称协程。

libco内部还为保存协程的调用链留了一个stack结构，而这个stack大小只有固定的128。
使用libco，如果不间断在一个协程中启动另一个协程，随着嵌套深度增加
就可能造成这个栈空间溢出。


