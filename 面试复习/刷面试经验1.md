### HTTP的幂等性？
无论调用url多少次，都不会有不同的结果的HTTO方法，不管你调用多少次结果都是一样的（前提是服务端的数据没有被人为修改）

GET幂等性：
- GET /tickets 获取ticket列表
- GET /tickets/12  查看某个具体的tickets
- POST /tickets 新建一个ticket
- PUT /tickets/12 更新ticket 12
- POST方法是HTTP的一个非幂等方法，调用多次会产生新的资源

POST可以获取数据吗？

可以

### Linux进程栈和堆是如何分配和释放的？
- 栈是由Linux系统产生，最终由系统释放
- 堆中的空间由有用户申请产生，最终必须由用户手动释放，否则会造成内存泄漏

线程栈在哪里分配的？

在PCB中进行分配，线程本身在产生的时候调用底层的clone函数，底层调用sys\_fork函数，指示在创建线程的时候传递侧参数和进程一样，
产生线程的函数从所处进程的PCB中复制需要的资源，即私有的栈地址

线程在进程的堆中分配栈空间，每个线程都拥有独立的栈空间，为了避免线程之间的占空间踩踏
，线程之间的会有以小块guardsize用来隔离保护各自的栈空间，一旦另一个线程踏入到这个隔离区，就会引发段错误

查看线程栈的大小：

可以看到默认情况下线程栈大小为8192，可以使用ulimit -s xxx修改线程栈大小

两个线程时，两个线程栈的总和不是固定值，也不是线程栈的2倍

线程从进程栈分配空间，大小并不是固定的，如果分配空间大于进程栈空间，那么直接运行时出现段错误

- TCP是如何处理粘包问题？

粘包是个伪概念。tcp协议是流协议，不存在数据包的概念，只是在应用层将数据封转成了数据包的形式。

定长发送，定长接收，两端商量使用相同的结构体

给数据头部设置包的长度，然后数据放在后面

使用特殊标记，在数据末尾使用特殊符号作为结束，对端识别出这个符号的时候，收包结束

使用其他第三方协议，像json，google protocol buffer等

### malloc的内存分配方式？

它有一个链接内存块的空闲链表

调用malloc函数的时候，它沿链接表寻址一个大到足以满足用户请求所需要的内存块。然后将该内存块
一共分为二（一块与用户申请的内存块相等，另一块就是剩下的字节），接下来，将分配给用户的那块内存传给用户，并将剩下的
那块返回到链接表上

调用free函数时，它将用户释放的内存块链接到空闲链表上，到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存段
，那么空闲链上可能没有可以满足要求的片段了，于是malloc函数请求延时，并开始在空闲链表上检查个片段，对他们进行睁开，将相邻的小空闲块合并成较大的内存块

----------------------------------
glibc另外的策略就是不止维护一类空闲链表，而是另外再维护一个缓冲链表和一个高速缓冲链表。

在分配的时候首先在高速缓存中查找，失败之后再在空闲链表查找，如果找到的内存块比较大，那么将切割之后的剩余内存块插入到缓存链表。

如果空闲链表查找失败那么就往缓存链表中查找. 如果还是没有合适的空闲块，就向内存申请比请求数更大的内存块，然后把剩下的内存放入链表中。

在对内存块进行了 free 调用之后，
我们需要做的是诸如将它们标记为未被使用的等事情，
并且，在调用 malloc 时，我们要能够定位未被使用的内存块。
因此， malloc返回的每块内存的起始处首先要有这个结构：

```c
struct mem_control_block {
    int is_available;
    int size;
};
```
malloc所申请的内存主要从Heap区域分配

进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址，才能真正使用。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。

Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。
由上文知道，要增加一个进程实际的可用堆大小，就需要将break指针向高地址移动。Linux通过brk和sbrk系统调用操作break指针。两个系统调用的原型如下：
```c
int brk(void *addr);
void *sbrk(intptr_t increment);
```
brk将break指针直接设置为某个地址，而sbrk将break从当前位置移动increment所指定的增量。brk在执行成功时返回0，否则返回-1并设置errno为ENOMEM；sbrk成功时返回break移动之前所指向的地址，否则返回(void \*)-1。

如果将increment设置为0，则可以获得当前break的地址。

另外需要注意的是，由于Linux是按页进行内存映射的，
所以如果break被设置为没有按页大小对齐，
则系统实际上会在最后映射一个完整的页，
从而实际已映射的内存空间比break指向的地方要大一些。
但是使用break之后的地址是很危险的
（尽管也许break之后确实有一小块可用内存地址）。
### 全局变量和静态变量？
static 生命的变量在C语言中有两方面的特征：
- 变量被放在程序的全局存储区中，
这样在下一次调用的时候还可以保持原来的赋值，
这一点是它与堆栈变量和堆变量的区别
- 变量使用static告知编译器，
自己仅在变量的作用范围中可见
这是与全局变量的区别

### emplace/emplace_front/emplace_back
- 调用emplace的时候，将参数传递给元素类型的构造函数，直接构造函数

### 面向对象的？面向对象的特性？有什么优点，比面向过程的语言好在哪？
???

### C语言函数参数压栈顺序？

从右往左，比如需要一些不定参数的函数，需要根据第一个参数来解析后面的参数位置，所以从
右往左压栈的话，可以首先解析第一个参数，推到后面的参数

### 命名管道和无名管道？
管道是IPC最基本的一种实现机制，我们都知道在Linux下“一切皆文件”，其实这里的管道就是一个文件。管道实现进程通信就是让两个进程都能访问该文件
- 匿名管道
管道只提供单线数据通信
只能用于具有血缘关系的进程间通信，通常用于父子进程间通信
管道是基于字节流来通信
本身自带同步互斥效果
- 命名管道

提供了一个路径名称与之关联，与FIFO文件的形式存储于文件系统中，能够实现任何两个进程之间通

### 进程和线程？

- 进程：是操作系统资源分配的基本单位，具有独立的用户地址空间3G和公共的内核地址空间1G
- 线程：是操作系统调度的基本单位，只有私有栈，没有自己的地址空间，共享进程中的资源
- 创建线程开销较小，一般创建一个进程需要的开销大约是10M左右
一个进程中至少有一个线程，线程不能离开进程独立存在
线程之间在多核的情况下可以实现真正的并行，而进程只能并发执行

### 守护进程，僵尸进程，孤儿进程，守护进程的作用是什么？

- 孤儿进程指在其父进程执行完成或被终止后仍继续运行的一类进程
- 僵尸进程指完成执行(通过exit系统调用，或者运行时致命错误或收到终止信号所致)
    但在操作系统的进程表中仍然有一个表项，处于终止状态的进程，这里指没有释放掉资源

处理僵尸进程的方法：
- 通过在父进程加
wait工作原理：子进程结束时，系统向其父进程发送SIGCHLD信号，父进程调用wait函数后阻塞
父进程被SIGCHLD信号唤醒，然后去回收僵尸进程；父子进程之间是异步的，SIGCHLD信号机制就是为了
解决父子进程之间的异步通信问题，让父进程可以及时的去回收僵尸进程
若父进程没有任何子进程则wait返回错误
- kill父进程解决，使僵尸进程被init进程收养
waitpid
- 基本功能一样，都是用来回收子进程
- waitpid可以回收指定pid的子进程
- waitpid可以阻塞式或者非阻塞式两种模式

- 守护进程：是一种在后台执行的电脑程序，此类程序会被以进程的形式初始化。
守护进程程序的名称通常以字母d结尾。独立与终端的进程，周期性的执行某种任务，守护进程脱离终端是为了避免进程在执行的
过程中的信息在任何终端上显示并且进程也不会被任何终端所产生的中断信息所打断

### 文件被删除了，没被释放是什么原因？

在linux中，通过rm或者文件管理器删除文件将会从文件系统的目录结构上解除链接，然而如果文件是被
打开的(有一个进程正在使用它)，那么进程仍然可以读取该文件，磁盘也就一直被占用。

解决方法：
首先获得一个为被进程占用的文件，进行删除


### 强类型，弱类型，静态类型，动态类型

- 强类型：强制数据类型定义的语言，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制类型转换，他就永远是这个类型
- 典型：C/C++/Java/C#
- 弱类型：数据类型可以被忽略的语言
#### 区别：能不能将一种很类型当作另一种类型

- 动态类型：运行期间才做类型检查的语言，即动态类型语言编程时，永远不用给任何变量指定数据类型，该语言会在第一次赋值给变量时，在内部将数据类型记录下来
- 静态类型：编译期间做检查数据类型语言，即写程序时要声明所有变量的数据类型，是固定的，使用数据类型之前，必须先声明数据类型
#### 区别：变量类型在编译时确认

#### 进程栈和线程栈的区别？

- 进程栈大小是在进程执行的时刻才能指定的，即不是编译的时候决定的，也不是在链接的时候决定的
- 进程栈大小是随机确定的，至少比线程栈大，但是不到线程栈的二倍
- 线程栈大小是固定的，也就是ulimit -a显示的值

ulimit -s xxx修改线程栈的大小

- 进程栈大小是执行时确定的，与编译器无关
- 进程栈大小是随机确认的，至少比线程栈要大，不会超过2倍
- 线程栈是固定的，可以使用ulimit -a查看，使用ulimit -s修改

### OPEN的过程

sys\_open函数
调用do\_sys\_open函数
这个函数完成了：调用get_unused_fd得到一个没有使用的，文件描述符
这是为读写准备，每个打开的文件都有一个文件描述符

调用do\_filep\_open构建struct file文件对象，并填充相关信息

调用fd\_install将文件对象和进程的file_struct 对象关联


do\_filp\_open函数功能是返回一个已经填充好的文件对象指针

#### READ的过程

调用后sys_read函数
切换进vfs

对于磁盘的一次读请求，首先经过虚拟文件系统层（vfs layer），
其次是具体的文件系统层（例如 ext2），接下来是 cache 层（page cache 层）、
通用块层（generic block layer）、IO 调度层（I/O scheduler layer）、
块设备驱动层（block device driver layer），最后是物理块设备层（block device layer）

### WRITE的过程

### 操作系统是如何调度进程的？

fork、vfork、clone三个系统调用都可以创建一个新进程，而且都是通过调用do\_fork来实现进程创建
Linux通过复制父进程创建一个新进程，那么这就给我们提供一个想像的框架：赋制pcb
要修改复制过来的进程数据，比如pid，进程链表等都要改改，见copy\_process内部
从用户态的代码看fork；函数返回了两次，即在父子进程中各返回一次，父进程从系统调用返回
比较容易理解，子进程从系统调用中返回，那他在系统调用中返回比较容易理解，子进程从西荣
调用中返回，那他在系统调用处理过程中哪里开始执行？
这就涉及子进程的内核堆栈数据状态和task\_struct中thread记录的sp和ip的一致性问题，在copy\_thread in copy\_process中设定


- 创建进程的过程？
首先复制父进程的task\_struct，并未父进程分配新的内核堆栈并在新的
内核堆栈里复制父进程内核堆栈中关于返回到用户态的返回信息
，并相应地修改返回地址与返回值0，接着对子进程  最初始化操作，
包括清空信号，关闭应当关闭的文件描述符，设置用户id等，最终子进程从该调用
退出，返回到被修改后的系统调用总控程序中的特定地址，进而返回到用户态，就执行。
而对于父进程来说并不会感受到这一切，只相当于调用了一个普通的系统调用，并返回
了子进程的pid

do\_fork系统内核调用：
- copy\_process 复制父进程的所有信息给子进程
- dup\_task\_struct 中为子进程分配了新的堆栈
- 调用sched\_fork并将新进程设置成task\_running
- copy\_thread中将父进程的寄存器上下文复制给子进程
- 设置ret\_from\_fork的地址为eip寄存器的值



进程调度的任务：

保存的处理机现场信息

按照某种算法选取进程，设置成运行态

将处理器分配给进程，有分派程序将处理器分配给该进程，将进程控制块内有关处理器现场的信息装入处理器
相应的各个寄存器，将处理器的控制权交给该进程，让他
从上次断点处恢复运行

- 正在运行的用户态进程x切换到运行用户态进程y的过程

正在运行的用户态进程

发生中断　保存cs:ip

save\_all保护进程现场

中断处理过程中或中断返回前调用了schedule，其中switch\_to做了关键的进程上下文切换

标号1之后开始运行用户态进程Y。这里Y曾经通过以上步骤切换出去过因此可以从标号1继续执行

restore\_all 恢复现场

iret-pop cs:ip ss:esp   eflags from kernel stack

继续运行用户态进程

swich\_to是一个宏而彼时一个函数，因此他的参数prev，next，last不是值拷贝，而是它的调用
者context\_switch中的局部变量，而调用swich\_to的时候，并不是通过普通call来实现，而是通过jmp
到switch\_to

### 消息队列

消息队列是一种进程间通信或者同一个进程的不同线程之间的通信方式，是一种异步的通信协议，包含发生事件的时间，输入设备的种类，以及特定的输入参数，也就是
说，消息的发送者和接受者不需要同时与消息队列交互，消息会保存在队列中，直到接收者取回它

实现：实际上消息队列常常保存在链表结构中，拥有权限的进程可以向消息队列中写入或读取消息

优缺点：消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息，这和大多数通信协议
是不同的

例如www中使用的http协议是同步的，因为客户端发出请求后那必须等待服务器回应，然而，许多情况下，我们需要异步的通信协议

比如一个进程通知另一个进程发生了一件事件，但不需要等待回应，但消息队列的异步特点，也造成了一个缺点，就是接受者必须轮训消息队列，才能收到最近的消息
和信号相比，消息队列能够传递更多信息，和管道相比，消息队列提供了有格式的数据，这可以减少开发人员的工作量，但消息队列仍然有大小限制





