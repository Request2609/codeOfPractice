请说明map和set的区别？分别是怎么实现？
map 和set底层实现都是红黑树，由于map和set所开放的各种操作接口，RB_Tree也提供了，几乎所有的map和set的操作行为
都只是转调RB_tree的操作行为

map中的元素是以key_value的形式存在的，key不可重复，set中的每一个元素都是一个key，在map和set中key或者关键字是不可重复出现的

set的迭代器是const的，不允许修改，在mao中允许修改value的值，不允许修改key的值，因为在map中根据key来在红黑树中排序的，在set中
是根据每个元素来保证有序性的，所以key或者元素的值修改，回导致红黑树重新调节平衡，这样会使整个容器的迭代器失效

map支持下表操作，set不支持下标操作，map可以用key做下标。

请介绍STL的allocator

STL的内存分配器，用于封装STL容器在内存管理的底层细节，在C++中，其中内存配置和释放如下：
new运算符分两个阶段：调用operaor new 配置内存-->调用对象构造函数构造对象内容
delete运算符分两个阶段：(1)调用对象析构函数(2)调用operator delete释放内存

为了精密分工，STL allocator将两个阶段操作区分开来：内存配置有alloc::dealocate负责，对象构造由construct负责，对象析构
有destroy负责
同时，为了提升内存管理效率，减少申请内存造成的内存碎片问题，当分配的空间超过128的时候，使用一级配置器，在分配空间大小
小于128B时，使用二级空间配置器，第一级空间配置器直接使用malloc，realloc、free函数进行内存空间的分配和释放，二级空间配置器
采用了内存池技术，通过空闲链表来管理内存

STL迭代器删除元素？

对于vector和deque来说，使用erase(iterator)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，erase
会返回下一个迭代器，对于map和set来说，使用erase删除iterator，当前元素的迭代器的失效，但是其结构是红黑树，删除当前元素，不会影响下一个元素
的迭代器，所以在调用erase之前，记录下一个元素的迭代器位置即可。对于list来说，它使用了不连续分配的内存，并且他的erase方法也会返回
下一个有效迭代器

C++中map的存放形式？
map是红黑树，unorder_map是哈希表

vector和list？

vector是动态变长数组，连续存储的容器，在堆上分配空间

底层实现：数组

两倍容量增长：vector增加的新元素时如果未超过当前的容量，则还有剩余空间，那就直接添加到最后，然后调整迭代器

如果没有剩余空间了，则会重新分配原有的元素个数的两倍空间，然后将原空间的元素通过复制的方式初始化新空间，面向新空间增加元素，最后
析构并释放原来的空间，之前的迭代器就会失效

访问：O(1)
插入：在最后插入，空间足够的情况下
在中间插入：内存拷贝
使用场景：经常随机访问，并且不经常对于非为节点进行插入删除

List
动态链表，在堆上分配空间，每插入一个元素就会分配一次空间，没删除一个元素，就会释放空间

底层：双向链表

和c语言中的数组和双向链表操作相似

迭代器的作用？

迭代器用于提供一种访问一个聚合对象的手段，不需要暴露对象内部的表示。
iterator模式是运用与聚合对象的一种模式，通过运用该对象，使我们可以再不知道对象内部表示的情况下，按照一定的顺虚顺序访问聚合对象
各个元素
由于iterator模式的以上特性：与聚合对象耦和，在一定程度上限制了他的广泛应用，一般仅用于底层聚合支持类，如STL的list，vector等容器和
ostream_iterator等

迭代器和指针的区别？

迭代器不是指针，是类模板，表现的像指针

迭代器模式又称为游标模式，用于提供一种顺序方位聚合元素的方法。在我们不知道聚合对象内部表示的情况下，按照一定顺序访问对象中的各个元素

由于迭代器模式的以上特征与聚合对象耦合，在一定程度上限制了他的广泛应用，一般仅用于底层支持类

迭代器不是指针，是类模板，表现的像指针，封装了原生指针，是指针概念的一种提升，提供了指针更高级的行为，相当于一种智能指针，他根据数据结构来实现不同的++,--操作
迭代器返回的是对象引用

迭代器产生的原因
迭代器访问的方式就是不同集合类的访问逻辑抽象出来的，使得不用暴露集合内部的结构而达到遍历集合的效果

STL中的resize和reverse的区别

resize改变当前容器中的含有的元素数量，reserve是改变容器的最大容量，只是确定这个容器允许放入多少对象


