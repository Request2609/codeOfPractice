在面向对象的过程中，对于很多重复出现的问题，总结出来解决这些问题的成功经验和最佳实践便形成了设计模式
核心思想是将可重用的解决方案总结出来，并分门别类，从而指导设计，减少代码重复和优化体系结构。

创型模式对类的实例进行了抽象，能够将软件模块中对象的创建和对象的使用分离，为了使软件的结构更加清晰，外界
对于这些对象只需要知道他们提供的接口，而不清楚具体实现的细节，使整个系统的设计更加符合单一职责原则

简单工厂模式：在一下情况下可以使用简单工厂模式：
工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中业务逻辑太过复杂
客户端只知道传工厂类的参数，对于如何创建对象不关心：客户端及不关心创建细节，甚至都不需要记住类名称，只需要知道
类型所对应的参数。
简单工厂模式违背了开闭原则，即在有新的产品加入到系统中的时候，必须修改工厂类，加入必要的处理逻辑，这违背了"开闭原则"

工厂方法模式：
工厂方法模式又称为工厂模式，也叫虚拟构造器或者多态模式。它属于对象创建型模式。在工厂方法模式中，工厂父类负责定义创建产品
对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类
来确定应该实例化那个具体产品类。
- 工厂方法包含如下角色：

抽象产品

具体产品

抽象工厂

具体工厂

在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责定义一个具体工厂必须
实现的接口，而不负责那一个产品类被实例化这种细节，这使得工厂方法可以允许系统在不修改工厂角色的情况下引进新产品。

- 工厂方法模式的优点：
在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了这种产品类的实例化细节，用户只需要关心所需产品对应的工厂
无
关心创建细节，甚至无需知道产品的

适配器模式
适配器提供给客户需要的接口，适配器的实现就是把客户类的请求转化成对适配者的相应接口调用，也就是说：当客户类调用适配器的方法时
用适配器类的方法，而这个过程对客户是透明的，客户类并不直接访问适配者类，适配器可以使由于接口不兼容而不能交互的类可以一起工作。

模式结构:
适配器模式包含如下角色：
Target  目标抽象类
Adatper  适配器类
Adaptee  适配者类
Client 客户类

适配器类的优点：
将目标类的和适配器类解耦
增加了类的透明性和复用性
灵活性和扩展性很好，符合开闭原则

可以再适配器类中置换一些适配者方法，使得适配器类的灵活性更强
类适配器的缺点：一个适配器只能适配一个适配者类，而且目标抽象类
只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类
和它的子类都适配到目标接口。

