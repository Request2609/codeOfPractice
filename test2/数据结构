### 平衡二叉树(AVL树)：
平衡二叉树又称为AVL树，是一种特殊的二叉排序树。
其左右子树都是平衡二叉树，并且左右子树高度之差的绝对值
不超过1，以树中的所有节点为根的树的左右子树高度之差的绝对值不超过
1。
左子树的深度减去右子树的深度的值称为平衡因子BF，那么平衡
二叉树上的所有节点的平衡因子只可能是-1，0和1。只要二叉树上有一个结点的平衡因子
的绝对值大于1，则该二叉树就是不平衡的。

红黑树是一颗二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑。通过
对任何一条从根到叶子路径会比其他的路径长出两倍，红黑树是一种弱平衡二叉树，相对
与要求严格的AVL树来说，他的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。

- 性质：
每个节点非红即黑;
根节点是黑色;
每个叶节点(叶节点即树尾端NULL指针)都是黑色;
如果一个节点是红色的，则其子节点必须是黑色;
对于任意节点而言，其到叶子点树NULL指针的每条路径
都包含相同数目的黑节点

AVL树是高度平衡的，频繁的插入和删除都会引起rebanlance，导致效率下降；红黑树的
不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转

### 哈弗曼编码

哈弗曼树的构建：
最简单的例子：给出一组数
4,3,1,2, 5,6

- 开始找出这组数中最小的两个1,2作为开始的两个叶子节点
给两个叶子节点求和，获得父节点3
- 这个时候数组的元素变成了 4,3,3,5,6继续找两个最小的数，即刚获取到的父亲节点3和数组与原本存在的
元素3，继续构建父亲节点6
- 这时候数组元素变为4,6,5,6，继续上述操作....

编码：
最终我们能构造一颗二叉树，可以叶子节点是原数组中的所有元素，
我们可以假设从根开始，到达每个叶子节点的路径，向左编码为1，向右编码为0，这样使得根节点到叶节点都可以获取一个唯一编码

### B+树

B树的定义
是一颗多路平衡查找树。描述一颗B树时需要指定它的阶数，阶数表示一个节点最多
有多少个孩子节点，一般用字母m表示阶数。当m取2的时候，就是我们常见的二叉搜索树。

一颗m阶的B树定义如下：
每个结点最多有m-1个关键字
根节点最少可以只有1个关键字
非根节点至少有Math.ceil(m/2)[也就是大于等于m/2的最小整数]-1个关键字
每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于
它，而右子树中的所有关键字都大于它。
每个叶子节点都是位于同一层，或者说根节点到每个叶子节点的长度都相同。

B+树是一种多路搜索树，主要为磁盘或者其他直接存取辅助设备而设计的一种平衡查找树
在B+树中，每个节点都可以有多个孩子的，并且按照关键字大小进行有序排列，所有
记录节点都是按照键值的大小顺序存放在同一层的叶节点中。相比于B树，其具有以下特点：

每个叶节点上的指针上限为2d而不是2d+1(d为节点的出度)
    内节点不存储data，只存储key
    叶节点不存储指针

### map和unordered_map优点和缺点？
- 优点
有序性：元素有序性在很多方面都会简化很多操作
对于map，其底层是基于红黑树实现的。有点：插入查找和删除时间复杂度稳定，都为logn

- 缺点
因为unordered_map内部基于哈希表，以key value对的形式存储，因此，空间占用率高
unordered_map的查找、删除、添加的事件复杂度不稳定，平均O(c)，取决于哈希函数，极端情况是O(n)

### epoll是如何实现的？它和select 的区别？

- 简单描述
epoll是通过红黑树和双向链表实现的。首先通过epoll_create系统调用在内核中的创建一个
eventpoll类型的句柄，其中包括红黑树根节点和双向链表头结点。然后通过epoll_ctl系统调用，
向epoll对象的红黑树结构中添加、删除、修改感兴趣的事件，返回0标识成功，-1失败。最后通过epoll_wait
系统调用判断双向链表是否为空，如果为空则阻塞。当文件描述符状态改变，fd上的回调函数被调用，该函数将fd加入到
双向链表中，此时epoll_wait函数被唤醒，返回就绪事件。

- 内核分析
相关的内核知识：
fd即文件描述符，在内核态，与之对应的是struct file结构，可以看做是内核态的文件描述符
spinlock自旋锁，当线程访问某资源条件不满足的时候，在循环不间断的访问，比较耗费CPU资源
引用计数
struct file是持有引用计数的

每创建一个epollfd，内核就会分配一个eventpoll与之对应，可以说是内核态的epollfd:

首先linux的file有个pollable的概念，只有pollable的file才可以加入到
epoll和select中，一个file是pollable的当且仅当其定义了file->f_op->poll。因为poll操作中
有外部提前设置好的callback注册到wait_queue中

wait_queue是事件驱动的，与驱动程序密切相关，简单来说poll函数
在file的触发队列中注册了一个callback，有事件发生时就调用callback。

epoll_create 只是在内核初始化一下数据结构，然后返回个fd
epoll_ctl支持添加移除fd，我们只看到添加的情况。epoll_ctl的主要操作
在epoll_ctl的主要操作在ep_insert，它主要：

初始化一个epitem，里面包含了fd，监听的事件，就绪链表，关联的epoll_fd等信息
调用ep_item_poll，ep_item_poll会调用vfs_poll，vfs_poll会调用file->f_op->poll，将ep_poll_callback注册到wait队列
调用ep_rbtree_insert将epitem插入eventpoll对象的红黑树中，方便后续查找

ep_poll_callback
ep_poll_callback被调用，说明epoll中某个file有了新事件
被调用的时候将file对应的epitem加到rdlist字段，用链表存着当前就绪的所有的epitem
ep_poll_callback被调用的时候，将file对应的epitem加到rdlist中
如果当前用户正在epoll_wait阻塞状态，ep_poll_callback还会通过wake_up_locked将epoll_wait唤醒

### TOP(K)问题

- 直接全部排序
只适合内存够的情况下
当数据量比较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的
方法是将数据全部排序。然后取排序后的数据中的前K个。

- 快速排序的变形

首先确定一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放在它的后面，完成一趟排序后，比较划分元的下标和K的大小，
要是划分元的下标正好等于K，那么这个划分元的序号(index)刚好等于K，那么这个划分元及左边所有的元就是K个最大元素，要是K的值小于划分元的index，
则继续递归index-1个数，进行以上排序操作。如果index<K，那么再从
划分元的右边继续进行排序，直到找到序号index刚好等于K为止。

- 最小堆

这是一种局部淘汰法。先读取前K个数，建立一个最小堆。然后将剩下的所有数字依次与最小堆的堆顶进行
比较，如果小于或者等于堆顶数据，继续下一轮比较，否则，删除堆顶元素，并将新数据插入到堆中，重新　调整最小堆，当遍历完成全部数据，最小堆中的数据就是最大的K个数。

- 分治法

将全部的数据分成n份，前提是每份的数据都可以读到内存中进行处理，
找到每份数据的最大K个数，此时剩下N*K个数据，
如果内存不能容纳N*K个数据，
则再继续分治处理，分成M份，
找出每份数据中最大的K个数，如果M*K个数仍然不能读到内存中
，那么可以对这些数使用快速排序的变形或者归并排序的处理

### 红黑树

红黑树是在AVL树的基础上发展而来的。红黑树是一种二叉查找树，但在每个节点
增加一个存储位表示节点的颜色，可以是红或者黑。通过对任何一条从根到叶子的路径上
各个节点着色的方式的限制，红黑树确保没有一条路径会比其他路径长出两倍，因此，红黑树
是一种弱平衡二叉树，相对于要求严格的AVL树来说，删除操作较多的情况下，通常使用红黑树。

性质：
所有节点要么是黑色，要么是红色
根节点是黑色的
每个叶子节点都是黑色
红色节点的孩子节点是黑色
从根节点到叶子节点的最长路径长度不超过最短路径长度的二倍

可以再O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。回复红黑属性需要少量O(logn)的颜色变更，并且不超过三次
树旋转。这允许插入和删除保持为O(logn)次

红黑树较AVL树的优点：
AVL树是平衡的，频繁的插入和删除，会引起频繁的自平衡，导致效率下降，红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，
删除最多三次旋转。
所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多
结构包括map底层实现都是使用红黑树。

红黑树旋转：
左旋和右旋

[红黑树](https://blog.csdn.net/qq_41681241/article/details/103434519)

### 堆栈
堆是由低地址向高地址扩展，栈是由高地址向低地址扩展
堆中的内存需要手动申请和自动释放；栈中内存是由OS自动申请和自动释放的，存放着参数，局部变量等内存。

堆中频繁调用malloc和free，会产生内存碎片，降低程序效率；而栈由于其先进后出的特性不会产生内存碎片。

堆的分配效率较低，栈的分配效率较高

栈效率高的原因：
计算机底层对栈提供的一系列支持，分配专门的寄存器存储栈的地址，
压栈和入栈有专门的指令执行；而堆是由c/c++函数库提供的，基质复杂，
需要一系列的内存分配，合并，释放等算法，因此效率低。

- 堆区和栈区的区别
申请方式：栈是由系统自动分配和管理，堆是由程序员手动分配和管理
效率：栈由系统分配，速度快，不会有内存碎片。
堆由程序员分配，速度较慢，可能由于操作不当产生内存碎片

扩展方向：栈从高地址到低地址进行扩展，堆由低地址向高地址进行扩展。

程序局部变量是使用的栈空间，new/malloc动态申请的内存是堆空间，函数调用时会进行参数和返回值的压栈出栈，也是用栈空间。

小根堆：若根节点存在子女则根节点的值小于左子女的值；若根节点存在右子女，则根节点的值小于右子女的值。
大根堆：若根节点存在左子女则根节点的值大于做子女的值，若存在右子女则根节点的值大于右子女的值。

### 数组和链表的区别？

数组是将元素在内存中连续的存放，可以通过下标直接访问元素，即在知道元素具体下标的情况，查找元素的效率是O(1)
插入元素和删除元素比较麻烦。插入数据时，这个位置后面的数据在内存中都要向后移动。删除元素时，这个数据后面的元素都要往前
移动。
数组随机读取效率高，内存是连续的，知道每个数据的内存地址，可以直接找到给地址的数据。如果应用需要快速访问数据，很少或不插入和删除元素，都应该用数组。数组需要预留空间，
在使用前要先申请占内存的大小，可能会浪费内存空间。并且数组不利于扩展，数组定义的空间不够时，要重新定义数组。

链表的特点：
链表中的元素在内存中不是顺序存储的，而是通过存储
元素中指针就可以了，如果应用需要经常，插入和删除元素你就需要用链表
数据结构，不指定大小，扩展方便。链表大小不用定义，数据随意增删。

各自的优缺点：
数组优点：
随机访问性强
查找速度快
数组的缺点：
插入删除效率低
可能浪费内存
内存空间要求高，必须要足够的连续内存空间
数组大小固定，不能动态扩展
链表的优点：
插入删除速度快
内存利用率高，不会浪费内存
大小没有固定，扩展灵活
缺点：
不能随机查找
必须从第一个开始遍历，查找效率低

### 求第k大数的方法，以及相同元素的时候会用什么不同的方法求第k
大的元素？

首先使用快速排序算法将数组按照从大到小的排序，然后直接取第k个，时间复杂度为O(nlogn)

使用堆排序，建立一个最大堆，然后调整堆，直到获取第k个元素
，其事件复杂度为O(n+klogn)

首先利用哈希表统计数组中元素出现的次数，然后利用计数排序的思想，
线性从大到小扫描过程中，前面有k-1个数则为第k大的数

利用快排思想，从数组中随机选择一个数i，然后将数组分成两部分Di，Dr，Di的元素都小于i，Dr的元素都大于i
然后统计Dr元素个数，如果Dr元素个数等于k-1，那么第k大的数即为k，如果Dr元素个数小于k，那么继续求Di中第k-Dr大的元素；
否则，求Dr中第k大的元素。

当相同元素的时候，首先利用哈希表统计数组中元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数，则为第k大的数，平均时间复杂度为O(n)

### 各种排序算法

- 冒泡排序：稳定　　　时间复杂度：O(n^2)
- 插入排序：稳定　　　　O(n^2)
- 希尔排序(缩小增量排序）：
         开始增量较大，分组较多，，每组的记录数较少，故在各组内采用
         直接插入排序较快，后来增量di逐渐减小，分组数减少，各组的记录数
         增多，但是由于已经按照di-1分组排序，文件较接近于有序状态，所以新的一趟排序过程较快，
         因此希尔排序在效率上比直接插入排序有较大的改进
在直接插入的基础上，将直接插入排序中的1全部改成增量d就行，因为希尔排序最后一轮增量d就是1
不稳定排序

- 选择排序：不稳定
平均时间复杂度：O(n^2)

- 快速排序：从待排序的n个记录中任选一个记录为分区标准；
把所有小于该排序列的记录移动到左边，大于的移动到右边，
中间放所选记录，称之为第一趟排序；
然后对前后两个子序列分别重复上述两个过程，直到所有记录都排好序

稳定性：不稳定
平均时间复杂度：O(nlogn)

- 堆排序
堆近似于完全二叉树
大顶堆：父节点不小于子节点键值
小顶堆：父节点不大于子节点键值，左右孩子没有大小顺序
堆排序在选择排序的基础上提出的，步骤：
１、建立堆
２、删除堆顶元素，同时交换堆顶元素和最后一个元素，再重新调整堆结构。直至全部删除堆中元素
稳定性：不稳定
平均时间复杂度：O(nlog(n))

- 归并排序

采用分治的思想，将序列分成一个个序列，对子序列进行排序
合并，直至整个序列有序

稳定性：稳定
平均时间复杂度：O(nlogn)

- 计数排序

思想：如果比元素x小的元素个数有n个，则元素x排序后位置为n+1
找出待排序数的数组中最大元素
统计数组中每个值为i的元素出现的次数，存入数组C的第i项
对所有的计数累加(从C的第一个元素开始，每一项和前一项相加)
反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减一
稳定性：稳定
时间复杂度：O(n+k)，k是待排序数的范围
- 桶排序
步骤：
设置一个定量的数组当做空桶子
寻访序列，并将记录一个一个放到桶子中；
对每个部位空的桶进行排序
从不是空的桶子中将项目再放回原来的序列中
时间复杂度：O(n+C)，C为桶内排序时间

稳定的排序：
基数排序
直接插入排序
折半插入排序
冒泡排序
归并排序

快速排序介绍和稳定性
根据哨兵元素，用两个指针指向待排序数组的首尾，首指针从前往后移动，
找到比哨兵大的元素，为指针从后往前移动找到比哨兵元素小的，交换两个元素，知道两个指针相遇，一趟排序完成

### hash表的实现
构造hash来说，主要包括直接地址法，平方取中法，除留余数法等

处理冲突的方法有开放地址法，再hash法，链地址法，建立公共溢出区等方法。
SGL版本使用链地址法，使用一个链表保持相同散列值的元素。

开放地址法：当发生冲突的时候，按照某种方法继续探测hash表中的其他存储单元，知道找到空位置为止。

再hash法：当发生hash冲突时使用另一个hash函数计算地址值，直到冲突不再发生。这种方法不易产生聚集，
但是增加计算时间，同事需要准备许多hash函数。

链地址法：将所有hash值相同的key通过链表存储，key按顺序插入到链表中

建立公共溢出区：采用一个溢出表存储产生冲突关键字。如果公共溢出区还产生冲突，再采用冲突方法处理。


判断链表是否是回文链表？
使用栈存储链表的前半部分，然后一个个出栈，与后半部分比较，
如果链表长度未知，可以使用快慢指针的方法，将慢指针指向的元素入栈，然后如果指针指向了链表尾部，此时满指针指向链表中间

判断两个链表是否相交？
(1)链表相交之后，后面的部分节点全部共用，可以用2个指针分别从这两个链表头部走向尾部，最后判断链表信息是否一致，要是一样，就是相交
(2)可以将其中一个链表信息保存到数组中，然后把另一个链表的每一个节点地址信息和数组中对比，要是相等，则跳出循环，说明相交。进一步优化则是进行hash排序，建立hash表
 
### 加密
单向加密
又称为不可逆加密，其秘钥是由加密散列函数生成的，单向散列函数一般用于产生消息摘要，秘钥加密，常见的有：

MD5，SHA，CRC-32主要提供校验功能
输入一样，输出必然相同
不可逆
定长输出
无论原始数据多大，结果大小都是相同的

对称加密
采用单钥密码系统的加密方式，同一个秘钥可以同时用作信息的加密和解密，即对称加密

### 什么事LRU缓存？

LRU最近最少使用算法根据数据的历史访问记录进行淘汰数据，其核心思想是如果数据最近被访问过，
那么将来被访问的效率也很高
实现：使用一个链表保存缓存数据，将新数据插入到头部，每当缓存命中时，将命中的数据移动到链表的头部，当链表满时，将链表尾部的数据丢弃

### OOP设计模式的五项原则

单一职责原则
接口隔离原则
开放封闭原则
替换原则
依赖倒置原则

